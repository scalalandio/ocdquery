<!DOCTYPE html><html><head><link href="META-INF/resources/webjars/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><link rel="shortcut icon" type="image/png" href="favicon.png" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><title>OCDQuery</title><script src="scripts.js"></script></head><body><div>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-145815618-1"></script>

<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-145815618-1');
</script>
<a href="https://github.com/scalalandio/ocdquery" style="position: absolute;top: 0px;right: 0px;border: 0;"><img src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub" /></a>

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="OCDQuery" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">OCDQuery<a class=" scalatex-site-Styles-headerLink" href="#OCDQuery" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /><h2 style="font-weight: 300;color: #ccc;padding: 0px;margin-top: 0px;">Scala library for repositories generating Doobie queries from higher-kinded data</h2></div><div class=" scalatex-site-Styles-content">
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="WhatOCDQuerydoes" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">What OCDQuery does<a class=" scalatex-site-Styles-headerLink" href="#WhatOCDQuerydoes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
      Overly-Complicated Database Query takes a case class defined by you and turns it into:</p>
    <ul>
      <li>
        config format for defining column-name-to-case-class-field mapping (with sane defaults)</li>
      <li>
        creation object allowing you to pass only certain fields to <code>INSERT</code> while the others will use <code>DEFAULT</code>s</li>
      <li>
        entity object fetched from database</li>
      <li>
        update object that let you update only certain fields without writing whole object at once</li>
      <li>
        filters for select, update and delete queries</li></ul>
    <p>
      Basically, it creates a repository basing on your (higher-kinded) case class.</p>
    <p>
      Additionally, repositories can be joined together to fetch tuples of objects.</p>
    <p>
      All returned results are <a href="https://tpolecat.github.io/doobie/">Doobie</a> queries.
</p>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Howtouseit?" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">How to use it?<a class=" scalatex-site-Styles-headerLink" href="#Howtouseit?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
      Add OCDQuery dependency to your build (currently released only for Scala 2.12):</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;io.scalaland&quot; %% &quot;ocdquery&quot; % &quot;0.4.1&quot;</code></pre>
    <p>
      If your model contains only fields populated and managed by API user, define it as value:</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">// values has one type param with a gap, used to wrap types of all fields
final case class ConfigF[Field[_]](
  operatingSystem: Field[String],
  numberOfCores:   Field[Int]
)</code></pre>
    <p>
      or if it has fields populated by database - assigned IDs, auto increment, <code>DEFAULT now()</code>, etc -
      (which can be tied to a records lifecycle) use entity:</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">import java.time.LocalDate
import java.util.UUID
// entities has two type params with gaps:
// - the first to fields passed manually on create,
// - the other fields created by database
final case class UserF[NormalField[_], CreatedField[_]](
  id:        CreatedField[UUID],
  name:      NormalField[String],
  surname:   NormalField[String],
  createdAt: CreatedField[LocalDate]
)</code></pre>
    <p>
      then create the repository out of it:</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">import cats.Id
import io.scalaland.ocdquery._
import shapeless.Generic

val ConfigFieldRepo = {
  implicit val configRead = QuasiAuto.read(Generic[ConfigF[Id]])
  Repo.forValue[ConfigF](&quot;cfgs&quot;.tableName, DefaultColumnNames.forValue[ConfigF])
}

val UserRepo = {
  implicit val userRead = QuasiAuto.read(Generic[UserF[Id]])
  Repo.forEntity[UserF](&quot;users&quot;.tableName, DefaultColumnNames.forEntity[UserF])
}</code></pre>
    <p>
      and you are set up!

      <h1 id="Configuringcolumnmappings" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Configuringcolumnmappings" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Configuring column mappings</h1>
        <p>
          Default column mappings returned by <code>DefaultColumnNames</code> assign the field name from the case class
          as the name of the column it is mapped to. You can modify it by updating all fields globally:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">import io.scalaland.ocdquery._

DefaultColumnNames.forValue[ConfigF].updateColumns(&quot;_&quot; + _)
DefaultColumnNames.forValue[ConfigF].updateColumns(_.toLowerCase)
DefaultColumnNames.forValue[ConfigF].snakeCaseColumns</code></pre>
        <p>
          or modify just the single field:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">DefaultColumnNames.forValue[ConfigF].copy[ColumnName](
  operatingSystem = &quot;os&quot;.columnName
)
DefaultColumnNames.forEntity[UserF].copy[ColumnName, ColumnName](
  name = &quot;name_&quot;.columnName
)</code></pre>
        <p>
          is it a but ugly, though, which is why I recommend using lenses library like
          <a href="https://github.com/softwaremill/quicklens">Quicklens</a></p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">import com.softwaremill.quicklens._
import io.scalaland.ocdquery._

DefaultColumnNames.forValue[ConfigF]
  .modify(_.operatingSystem).setTo(&quot;os&quot;.columnName)
DefaultColumnNames.forEntity[UserF]
  .modify(_.name).setTo(&quot;name_&quot;.columnName)</code></pre>
        <p>
          or <a href="http://julien-truffaut.github.io/Monocle">Monocle</a>:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">import io.scalaland.ocdquery._
import monocle.macros.syntax.lens._

DefaultColumnNames.forValue[ConfigF]
  .lens(_.operatingSystem).set(&quot;os&quot;.columnName)
DefaultColumnNames.forEntity[UserF]
  .lens(_.name).set(&quot;name_&quot;.columnName)</code></pre>
        <p>
          (I will use Quicklens for the following examples).
</p>
      <h1 id="Insertingnewdata" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Insertingnewdata" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Inserting new data</h1>
        <p>
          In order to insert new data you just need to pass it into <code>.insert</code> method:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">// value example - value looks the same during creation as later
ConfigRepo.insert(
  ConfigF[Id](&quot;Windows&quot;, 4)
).run

// entity example
// entity has some fields created, so they kind of &quot;disappear&quot; from the type
// - in such case it is prettier to create them from a tuple containing
// only required fields
UserRepo.insert(
  Create.forEntity[UserF].fromTuple((&quot;John&quot;, &quot;Smith&quot;))
).run
</code></pre>
      <h1 id="Fetchingexistingdata" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Fetchingexistingdata" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Fetching existing data</h1>
        <p>
          To fetch existing data you need to use <code>.fetch</code> and specify some filter:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">import io.scalaland.ocdquery.sql._ // definitions common for all SQLs

// fetch all
ConfigRepo.fetch(_ =&gt; emptyFiler).to[List]

// filter by column=value/column&lt;&gt;value
ConfigRepo.fetch(_.operatingSystem `=` &quot;Windows&quot;).to[List]
ConfigRepo.fetch(_.operatingSystem &lt;&gt; &quot;Windows&quot;).to[List]

// filter by column1=column2/column1&lt;&gt;column2
UserRepo.fetch(cols =&gt; cols.name `=` cols.surname).to[List]
UserRepo.fetch(cols =&gt; cols.name &lt;&gt; cols.surname).to[List]

// filter using IN
ConfigRepo.fetch(_.numberOfCores.in(2, 4, 6)).to[List]

// filter using (NOT) BETWEEN
ConfigRepo.fetch(_.numberOfCores.between(4 8)).to[List]
ConfigRepo.fetch(_.numberOfCores.notBetween(4 8)).to[List]

// filter using LIKE
ConfigRepo.fetch(_.operatingSystem.like(&quot;Windows%&quot;)).to[List]

// AND, OR and NOT are also available
UserRepo.fetch { cols =&gt;
  (cols.name `=` &quot;John&quot;) and (cols.surname `=` &quot;Smith&quot;)
}.option</code></pre>
        <p>
          You can also sort and paginate results:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">UserRepo
  .fetch
  .withSort(_.surname, Sort.Ascending)
  .withOffset(5)
  .withLimit(10)(_ =&gt; emptyFiler).to[List]</code></pre>
        <p>
          or calculate the size of the result, or check if it would be not empty:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">UserRepo.count(_ =&gt; emptyFiler).unique
ConfigRepo.exists(_.operatingSystem `=` &quot;BeOS&quot;).unique
</code></pre>
      <h1 id="Updatingexistingdata" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Updatingexistingdata" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Updating existing data</h1>
        <p>
          In order to <code>.update</code> data you have to filter which rows should be updated and define which
          should be set to specific values:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">UserRepo.update(_ =&gt; emptyFilter)(UserRepo.emptyUpdate).run</code></pre>
        <p>
          <code>emptyUpdate</code> is similar to <code>DefaultColumnNames</code> - it can be modified using <code>.copy</code>
          or (my suggestion) by lens:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">UserRepo.update(_.surname `=` &quot;Smith&quot;)(
  UserRepo.emptyUpdate.modify(_.name).setTo(&quot;Johnny&quot;)
).run
</code></pre>
      <h1 id="Deletingdata" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Deletingdata" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Deleting data</h1>
        <p>
          Delete works similar to filtering except it will remove all that it matches instead of returning:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">UserRepo.delete(_.name &lt;&gt; &quot;John&quot;).run
</code></pre>
      <h1 id="Fetchingtuples" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Fetchingtuples" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Fetching tuples</h1>
        <p>
          When you take a <code>Repo</code> and call a <code>.join</code> on it, you will obtain <code>Fetcher</code>, which cannot
          modify data, but it can fetch a tuple of types from both repositories. <code>Fetcher</code> can be again
          combined with a <code>Repo</code> to obtain a <code>Fetcher</code> of triple, then quadruple, etc:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">UserRepo.join(UserRepo) // Fetcher of (User, User)
UserRepo.join(UserRepo).join(UserRepo) // Fetcher of (User, User, User)</code></pre>
        <p>
          during joining you can define the type of <code>JOIN</code> by passing <code>JoinType</code> and then you can
          define <code>ON</code> condition(s):</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">UserRepo.join(UserRepo, JoinType.OUTER)
  .on(_._1.name, _._2.surname) // columns for ON come from tuple</code></pre>
        <p>
          Once you build a Fetcher you can <code>.fetch</code> data using the same way it works with repository
          (except that now you extract columns from tuple):</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">UserRepo.join(UserRepo).join(UserRepo).fetch { cols =&gt;
  (cols._1.surname &lt;&gt; cols._2.surname) and
    (cols._1.surname &lt;&gt; cols._3.surname) and
    (cols._2.surname &lt;&gt; cols._3.surname)
}.to[List]
</code></pre></p>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Howitworks?" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">How it works?<a class=" scalatex-site-Styles-headerLink" href="#Howitworks?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <h1 id="Initialidea" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Initialidea" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Initial idea</h1>
      <p>
        Imagine you wanted to generate queries from data objects.</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">import java.util.UUID
import java.time.LocalDate

final case class Ticket(
  id:      UUID,
  name:    String,
  surname: String,
  from:    String,
  to:      String,
  date:    LocalDate
)


import doobie._
import doobie.implicits._

object TicketRepo {
  // ...
}</code></pre>
      <p>
        You may want to be able to insert new entity:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">final case class TicketCreate(
  id:      Unit,   // placeholder as this is created by database
  name:    String,
  surname: String,
  from:    String,
  to:      String,
  date:    LocalDate
)

object TicketRepository {
   // ...
   def insert(entity: TicketCreate): Update0 = ???
   // ...
}</code></pre>
      <p>
        You may want to be able to fetch data using some obligatory part of the fetching (e.g. ID)
        and maybe some optional parts (having other field equal to some value):
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">final case class TicketFilter(
  id:      Option[UUID],     // where id      = [this value if set]
  name:    Option[String],   // and   name    = [this value if set]
  surname: Option[String],   // and   surname = [this value if set]
  from:    Option[String],   // and   from    = [this value if set]
  to:      Option[String],   // and   to      = [this value if set]
  date:    Option[LocalDate] // and   data    = [this value if set]
)

object TicketRepository {
   // ...
   def update(entityFind: TicketFilter): Query0[Ticket] = ???
   // ...
}</code></pre>
      <p>
        You might want to update existing entity using case class - this you make building queries easy.</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">final case class TicketUpdate(
  id:      Option[Unit],     // set uuid    = [this value if set],
  name:    Option[String],   //     name    = [this value if set],
  surname: Option[String],   //     surname = [this value if set],
  from:    Option[String],   //     from    = [this value if set],
  to:      Option[String],   //     to      = [this value if set],
  date:    Option[LocalDate] //     data    = [this value if set]
)

object TicketRepository {
   // ...
   def update(entityUpdate: TicketUpdate): Update0 = ???
   // ...
}</code></pre>
      <p>
        And you might want to delete entity using fetch criteria:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">object TicketRepository {
   // ...
   def delete(entityDelete: TicketFilter): Query0[Ticket] = ???
   // ...
}</code></pre>
      <p>
        In all these cases having some object that defines how query will be performed
        might be really useful. We could get a lot of queries almost for free.</p>
      <p>
        All these case classes can easily get out of sync, so it would be good
        if something could enforce that adding field in one place will require adding
        it somewhere else.</p>
      <p>
        If we operated under that assumption, we would be able to derive queries
        automatically. That is as long as we had two more pieces of information
        table name and:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">final case class TicketColumns(
  id:      String,
  name:    String,
  surname: String,
  from:    String,
  to:      String,
  date:    String
)</code></pre>
    <h1 id="Ideaofarefactor" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Ideaofarefactor" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Idea of a refactor</h1>
      <p>
        If we take a closer look, we'll see that we have 3 case classes that are
        virtually identical - if we were able to flip the type of some fields from
        <code>A</code> to <code>Option[A]</code> to turn entity to update, or all of them to <code>String</code>
        to turn it into column configuration, we would reduce the amount of code
        and fixed issue of case class synchronization.</p>
      <p>
        And we can do this! The idea is called higher-kinded data and looks like this:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">import java.time.LocalDate
import java.util.UUID

type Id[A] = A // removed F[_] wrapper
type UnitF[A] = Unit // make fields not available at creation &quot;disappear&quot;
case class ColumnName[A](name: String) // preserves name of column and its type

// F is for normal columns which should be available in some what
// for all lifecycle
// C is for these that should be empty during creation and available
// from then on
final case class TicketF[F[_], C[_]](
  id:      C[UUID],
  name:    F[String],
  surname: F[String],
  from:    F[String],
  to:      F[String],
  date:    F[LocalDate]
)

// C[_] fields are Units, the rest as of type inside of F[_]
type TicketCreate  = TicketF[Id, UnitF]
// all fields are of the type inside of F[_]/C[_]
type Ticket        = TicketF[Id, Id]
// all fields are of Option of inside of F[_]/C[_]
type TicketUpdate  = TicketF[Option, Option]
// all fields are column names
type TicketColumns = TicketF[ColumnName, ColumnName]</code></pre>
      <p>
        Higher-kinded data is data with higher-kinded types as type parameters.</p>
      <p>
        This library is about taking this higher-kinded data definition and generating basic CRUD queries for it.
</p>
    <h1 id="Implementation" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Implementation" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Implementation</h1>
      <p>
        During implementation some decisions had to be made:</p>
      <ul>
        <li>
          instead of <code>Option</code> we use our own <code>Updatable</code> type which could be <code>UpdatedTo(to)</code> or <code>Skip</code>
          to avoid issues during derivation that would occur if you had e.g. <code>O[Option[String]]</code>
          as one of field types,</li>
        <li>
          derivation metadata is stored inside <code>RepoMeta[EntityF]</code> instance - you can reuse
          on your own, if the default autogenerated queries doesn't suit your use case:
          <pre><code class="scala scalatex-site-Styles-highlightMe">import doobie._
import doobie.implicits._
import io.scalaland.ocdquery._

val ticketRepoMeta = RepoMeta.forEntity(
  &quot;tickets&quot;.tableName,
  DefaultColumnNames.forEntity[TicketF]
    .modify(_.from).setTo(&quot;from_&quot;.columnName)
)

val ticketRepo = new EntityRepo(ticketRepoMeta)</code></pre></li></ul>
       <li>
         to avoid writing <code>EntityF[Id, Id]</code>, <code>EntityF[Updatable, Updatable]</code> and <code>EntityF[Id, UnitF]</code>
         manually, some type aliases were introduced:
         <pre><code class="scala scalatex-site-Styles-highlightMe">import io.scalaland.ocdquery._

type TicketCreate = Repo.ForEntity[TicketF]#EntityCreate
type Ticket       = Repo.ForEntity[TicketF]#Entity
type TicketUpdate = Repo.ForEntity[TicketF]#EntityUpdate</code></pre></li>
       <li>
         if you want to extend filtering DSL you can write your own extension methods like:
         <pre><code class="scala scalatex-site-Styles-highlightMe">implicit class MyNewFiltering(columnName: ColumnName[Int]) {

  def &lt;(number: Int): Filter = () =&gt; columnName.fragment ++ fr&quot;&lt; $number&quot;
}
</code></pre></li>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="HowtoextendDSL?" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">How to extend DSL?<a class=" scalatex-site-Styles-headerLink" href="#HowtoextendDSL?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
      Actually, repositories doesn't assume much about the types they work on. They only assume that <code>RepoMeta</code>
      instances follow their contracts, that is, they return reasonable <code>doobie.Fragment</code> values for each input.</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">new Repo(repoMeta) // Repo only uses functionality of RepoMeta</code></pre>
    <p>
      <code>RepoMeta</code> on the other hand rely on values derived from types - derivation of these type classes uses by
      RepoMeta is where the library actually relies on the fact the we use higher-kinded data. BUT, if you write them
      yourself, you are free to do it for any combination of types that makes sense for you.</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">// common operations for all kinds of Repos
sealed trait RepoMeta[Create, Entity, Update, Names] {
  val table:       Fragment                 // table name, with or without alias
  val columnNames: ListSet[ColumnName[Any]] // required by SELECT

  // turns different types into ColumnName -&gt; column value Map
  val fromCreate: Create =&gt; ListMap[ColumnName[Any], Fragment]
  val fromEntity: Entity =&gt; ListMap[ColumnName[Any], Fragment]
  val fromUpdate: Update =&gt; ListMap[ColumnName[Any], Fragment]

  lazy val * : Fragment = ... // * for SELECT
}

// Repo which isn't using aliases in FROM - for simple SELECT without JOINs
sealed trait UnnamedRepoMeta[Create, Entity, Update, Names]
    extends RepoMeta[Create, Entity, Update, Names] {

  // main use case: for F=Id pass Names =&gt; ColumnName
  // to obtain e.g. column in ORDER BY
  def unnamedColForNames[F[_]: Functor](
    f: Names =&gt; F[ColumnName[Any]],
    prefix: Option[String] = None
  ): F[ColumnName[Any]]
  // used for filtering
  def unnamedColForFilter(f: Names =&gt; Filter,
                          prefix: Option[String] = None): Filter

  // provides alias in FROM
  def as(name: String): NamedRepoMeta[Create, Entity, Update, Names] = ...
}

// Repo which uses aliases - only aliased Fragments can be used in JOINed queries
sealed trait NamedRepoMeta[Create, Entity, Update, Names]
    extends RepoMeta[Create, Entity, Update, Names] {

  // everything that goes into ON
  val joinedOn: Option[Fragment]

  // for ORDER BY
  def namedColForNames[F[_]: Functor](
    f: Names =&gt; F[ColumnName[Any]]
  ): F[ColumnName[Any]]
  // for filtering
  def namedColForFilter(f: Names =&gt; Filter): Filter

  // JOIN (without ON), prevents nested tuples
  // A join B =&gt; (A, B)
  // (A, B) join C =&gt; (A, B, C)
  // (A, B, C) join D =&gt; (A, B, C, D)
  // etc
  def join[C1, E1, S1, N1](
    meta:     NamedRepoMeta[C1, E1, S1, N1],
    joinType: JoinType = JoinType.Inner
  )(implicit
    cta: TupleAppender[Create, C1],
    eta: TupleAppender[Entity, E1],
    sta: TupleAppender[Update, S1],
    nta: TupleAppender[Names, N1]
  ): NamedRepoMeta[cta.Out, eta.Out, sta.Out, nta.Out] = ...

  // fills ON after JOIN
  def on(
    left:  Names =&gt; ColumnName[Any],
    right: Names =&gt; ColumnName[Any]
  ): NamedRepoMeta[Create, Entity, Update, Names] = ...
}

object RepoMeta {

  // combines derived type classes into RepoMeta
  def instant[Create, Entity, Update, Names](
    tableName: TableName,
    columns:   Names
  )(
    implicit cols: AllColumns[Names],
    forCreate:     ColumnNameFragmentList[Create, Names],
    forEntity:     ColumnNameFragmentList[Entity, Names],
    forUpdate:     ColumnNameFragmentList[Update, Names],
    updateColumns: UpdateColumns[Names]
  ): UnnamedRepoMeta[Create, Entity, Update, Names] = ...

  // other methods
}</code></pre>
    <p>
      By analysing these you should be able to understand how to define your own arbitrary Repo
      by defining <code>AllColumns</code>, <code>ColumnNameFragmentList</code> and <code>UpdateColumns</code> instances.</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">type ArbitraryColumns // ColumnName[A] fields only - config and filters
type ArbitraryCreate  // only fields present at creation
type ArbitraryEntity  // all fields
type ArbitraryUpdate  // Updatable[A] fields only - for defining updates
implicit val allColumns: AllColumns[ArbitraryColumns] = ...
implicit val forCreate: ColumnNameFragmentList[ArbitraryCreate,
                                               ArbitraryColumns] = ...
implicit val forEntity: ColumnNameFragmentList[ArbitraryEntity,
                                               ArbitraryColumns] = ...
implicit val forUpdate: ColumnNameFragmentList[ArbitraryUpdate,
                                               ArbitraryColumns] = ...
new Repo(RepoMeta.instance(&quot;table&quot;.tableName, allColumnsNames))</code></pre>
    <p>
      Additionally, <code>Filter</code>s are implemented as Single Abstract Methods <code>() =&gt; doobie.Fragment</code>, so you
      can easily write your own <code>ColumnName[A] =&gt; Filter</code> extension methods (see package <code>sql</code>).</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">implicit class MyNewFiltering(columnName: ColumnName[Int]) {

  def &lt;(number: Int): Filter = () =&gt; columnName.fragment ++ fr&quot;&lt; $number&quot;
}
</code></pre>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Limitations" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Limitations<a class=" scalatex-site-Styles-headerLink" href="#Limitations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <ul>
      <li>
        Library assumes that <code>EntityF</code> is flat, and automatic generation of Doobie queries is done in a way which
        doesn't allow you to use <code>JOIN</code>s, nested <code>SELECT</code>s etc. If you need them you can use utilities from
        <code>RepoMeta</code> to write your own query, while delegating some of the work to <code>RepoMeta</code>
        (see how <code>Repo</code> does it!).</li>
      <li>
        Using <code>EntityF</code> everywhere is definitely not convenient. Also it doesn't let you
        define default values like e.g. <code>None</code>/<code>Skipped</code> for optional fields. So use them
        internally, as entities to work with your database and separate them from
        entities exposed in your API/published language. You can use <a href="https://github.com/scalalandio/chimney">chimney</a>
        for turning public instances to and from internal instances,</li>
      <li>
        types sometimes confuse compiler, so while it can derive something like <code>shapeless.Generic[TicketF[Id, Id]]</code>,
        it has issues finding <code>Generic.Aux</code>, so Doobie sometimes get's confused - <code>QuasiAuto</code> let you provide
        the right values explicitly, so that the derivation is not blocked by such silly issue.</li></ul></div>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"OCDQuery","children":[{"value":"What OCDQuery does","children":[]},{"value":"How to use it?","children":[{"value":"Configuring column mappings","children":[]},{"value":"Inserting new data","children":[]},{"value":"Fetching existing data","children":[]},{"value":"Updating existing data","children":[]},{"value":"Deleting data","children":[]},{"value":"Fetching tuples","children":[]}]},{"value":"How it works?","children":[{"value":"Initial idea","children":[]},{"value":"Idea of a refactor","children":[]},{"value":"Implementation","children":[]}]},{"value":"How to extend DSL?","children":[]},{"value":"Limitations","children":[]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      